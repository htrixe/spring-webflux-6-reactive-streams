# Experiencing Reactive Programming

## Reactive Programming

### Reactive Streams

 ### - Project Reactor and Spring WebFlux

Project Reactor is a library that implements all reactive stream specifications, and it comes with some very powerful features. Project Reactor brings us two major components, types and operators. The types introduced by Project Reactor are mono and flux. Other operators may be very familiar to you if you've previously worked with Java streams. Operators, such as map, filter, and flatMap, are also in the Project Reactor. We're going to explore a lot of operators during the next modules, but for now, let's focus on the types. A flux represents a flux of data that emits certain signals. When the connection between the publisher and subscriber is realized, an onSubscribe signal is emitted. Then, the publisher starts pushing events. First, it pushes a circle. When that occurs, another signal is emitted called onNext. Actually, every time the publisher pushes a new data item, an onNext signal is generated. Each onNext event contains the data item produced by the publisher. After all items are sent, the publisher can tell the subscriber it finished pushing all events by emitting an onComplete signal. The mono type works in a similar fashion. When the subscriber connects to a mono publisher, an onSubscribe signal is emitted. The mono publisher then starts sending its data. In that moment, an onNext signal is emitted. However, here is the main difference between a mono and a flux. While using monos, we are certain that only one data item is sent before the onComplete signal is emitted. Mono comes from the ancient Greek, meaning one or single, so, while using monos, we are only receiving one data item, whereas with flux, we can receive more than one before closing the data stream. But, what if something bad happens while the transfer is in progress? Let's say our subscriber successfully connects to our publisher. The publisher manages to push a few data items, but then the network connection is interrupted. In this case, an onError signal is emitted. This helps us gracefully handle exceptional scenarios. I hope you didn't forget there is one more thing we need to talk about, and that is the actual topic of this course, Spring WebFlux. Spring WebFlux takes advantage of all the concepts and components we discussed until this point and brings them to the Spring framework. Even the title is highly suggestive. First, we have the web part, which in Spring we already have the Spring Web MVC framework. The Spring Web MVC framework is based on the Servlet API, a rather old specification that provides web capabilities in a blocking fashion. The need for non‑blocking capabilities pushed the Spring framework to adopt a new stack called WebFlux. Spring WebFlux is using Project Reactor under the hood, which evidently, is using the Reactive Streams specification and not the Servlet API.   But, how did we end up with this need? In the past, we dealt with monolithic applications, which required a minimal I/O interaction, mostly represented by connections to the database. Today, we are dealing with microservices architectures that perform a lot more network calls than a monolith. All these network calls are I/O operations that block code execution from the moment they start. By adopting a reactive approach, we are able to handle concurrency with a smaller number of threads and fewer hardware resources.

 ### - Project Loom
 If you've been closely following the Java community, you are probably aware that something big is underway. Project Loom is an open‑source initiative that aims to introduce lightweight and scalable concurrency tools for the Java programming language. It has been introduced as a preview feature in Java 19, but an exact timeline for its stable release is yet to be determined. Now, why should we care about this project? While this approach may seem fine, it has some drawbacks. Firstly, creating and deleting threads can be quite expensive, especially when a large number of threads are needed. If an application requires only a few threads, this may not be a concern. However, if an application needs to create hundreds of threads, it can significantly impact performance. Additionally, threads can sometimes end up in a blocked state due to synchronization, waiting for resources such as a database connection or file, or during I/O operations. Lastly, context switching is a process where the execution context of one thread is saved and that of another thread is restored, allowing multiple threads to share the CPU. The JVM will manage everything, allowing for efficient management of thousands of threads with minimal overhead. Now, the question arises, if project loom solves the threading problem, do we still need reactive programming? Most likely, yes. There are specific use cases where reactive programming can still be advantageous. These include sending and processing async signals, establishing bidirectional communication between client and server, and enabling stream processing. Reactive programming and WebFlux offers out‑of‑the‑box implementations for these processes, eliminating the need for additional libraries or frameworks.

 






